# 大界机器人
## 一面
>1、依赖属性是什么
2、依赖注入的生命周期、报错，怎么分析错误、依赖注入有哪几种方式使用过哪几种
3、WPF资源
4、WPF绑定的原理
5、多线程相关
6、ORM相关原理
7、面向接口设计的优点




### 解答：
#### 1、依赖属性是什么

#####  **. 依赖属性（Dependency Property）**

- **定义**：WPF/Silverlight中用于扩展CLR属性的系统，支持数据绑定、动画、样式等特性。
    
- **特点**：
    
    - **属性继承**：子元素可继承父元素的属性值（如`FontSize`）。
        
    - **自动变更通知**：通过`PropertyChangedCallback`响应属性值变化。
        
    - **节省内存**：非静态值存储于全局`EffectiveValueEntry`中，按需分配。
        
- **实现**：使用`DependencyProperty.Register`静态方法注册。
    
- **对比CLR属性**：依赖属性通过依赖对象（`DependencyObject`）管理，支持复杂交互场景。

####  2、依赖注入的生命周期、报错，怎么分析错误
#####  **2. 依赖注入（DI）生命周期与错误分析**

- **生命周期**：
    
    - **Transient**：每次请求创建新实例。
        
    - **Scoped**：同一作用域内共享实例（如HTTP请求）。
        
    - **Singleton**：全局单例。
        
- **常见错误**：
    
    - **服务未注册**：抛出`InvalidOperationException`。
        
    - **循环依赖**：A依赖B，B又依赖A。
        
    - **生命周期不匹配**：如Scoped服务注入到Singleton中。
        
- **分析步骤**：
    
    1. 检查异常消息，定位未注册的服务或依赖关系。
        
    2. 使用日志记录容器构建过程。
        
    3. 工具辅助：如.NET的`dotnet watch`或第三方DI分析器。
#### 3、WPF资源
#####  **3. WPF资源**

- **资源类型**：
    
    - **静态资源（StaticResource）**：加载时一次性解析。
        
    - **动态资源（DynamicResource）**：运行时动态更新（如主题切换）。
        
- **作用域**：
    
    - **应用程序级**：`App.xaml`中定义，全局可用。
        
    - **窗口/控件级**：在窗口或控件`Resources`标签内定义，局部有效。
        
- **用途**：存储样式（`Style`）、模板（`ControlTemplate`）、画刷（`Brush`）等可重用对象。
-
#### 4、WPF绑定的原理
#####  **WPF绑定原理**

- **核心机制**：
    
    - **绑定源与目标**：通过`Binding`对象关联源属性（如ViewModel）与目标属性（如UI控件）。
        
    - **数据流方向**：`Mode`控制方向（`OneWay`、`TwoWay`等）。
        
    - **更新触发**：`UpdateSourceTrigger`决定何时同步数据（如失去焦点时）。
        
- **底层实现**：
    
    - 依赖属性系统监听属性变化。
        
    - `INotifyPropertyChanged`接口通知绑定目标更新。
        
    - 使用`BindingExpression`管理绑定状态。
#### 5、多线程相关
#####  **5. 多线程关键点**

- **线程与任务**：
    
    - **Thread**：底层线程管理，需手动处理同步。
        
    - **Task**：基于线程池，支持`async/await`异步模型。
        
- **同步机制**：
    
    - **lock/Monitor**：临界区保护。
        
    - **Semaphore/Mutex**：控制资源访问数量。
        
    - **Concurrent Collections**：线程安全集合（如`ConcurrentQueue`）。
        
- **常见问题**：
    
    - **死锁**：多个线程互相等待资源释放。
        
    - **竞态条件**：未同步导致数据不一致。

#### 6、ORM相关原理
#####  **ORM原理**

- **核心功能**：
    
    - **对象-表映射**：将类映射到数据库表，属性映射到列。
        
    - **查询转换**：将LINQ或方法链转换为SQL（如EF Core）。
        
    - **变更跟踪**：自动检测实体状态变化，生成更新语句。
        
- **工作模式**：
    
    - **Code First**：通过代码定义模型，生成数据库。
        
    - **Database First**：从现有数据库生成模型类。
        
- **性能优化**：
    
    - **延迟加载**：按需加载关联数据。
        
    - **批处理**：合并多个SQL操作减少开销。
#### 7、面向接口设计的优点
#####  **7. 面向接口设计的优点**

- **解耦**：接口隔离实现与使用，降低模块依赖性。
    
- **可测试性**：通过Mock接口实现单元测试。
    
- **扩展性**：新增实现类无需修改现有代码（符合开闭原则）。
    
- **多态支持**：同一接口可承载不同实现（如策略模式）。
    
- **依赖注入**：便于通过接口注入具体服务。

## 二面准备（根据简历）
```
1、什么是委托？委托分几种？有什么区别？平时用过哪几种？
2、什么是事件？
3、什么是泛型？
4、什么是多线程？
5、在简历中提到熟悉C#高级语法，能否举例说明**委托和事件**在实际项目中的应用场景？在多线程环境下如何避免事件引发的线程安全问题？
6、在WPF中，**依赖属性**与普通CLR属性的核心区别是什么？请用代码片段说明如何定义一个依赖属性，并解释其数据绑定机制。
7、使用ASP.NET Core时，如何实现**依赖注入的生命周期管理**（Transient/Scoped/Singleton）？如果将一个Scoped服务注入到Singleton中，会导致什么问题？
8、**EFCore的变更跟踪机制**是如何工作的？在批量更新数据时，如何通过`AsNoTracking()`优化性能？
9、你提到熟练使用Dapper，对比EFCore，Dapper在哪些场景下更具优势？请举例说明
10、在C#中，**Task和Thread**的区别是什么？如何通过`async/await`避免阻塞UI线程？
11、 使用`ConcurrentQueue`时，如果多个线程同时进行读写操作，如何确保数据一致性？请结合代码说明。
12、 你使用过NModbus和S7.NetPlus，能否解释**Modbus TCP协议**与**S7协议**的核心差异？在开发通讯工具时，如何保证数据的实时性和可靠性？
13、在优化WMS系统时，你提到“通过精细调整数据库部署”提升了效率，具体做了哪些优化（如索引设计、查询优化）？请举例说明。
14、使用Vue3+ElementPlus开发WCS系统时，如何实现前后端数据的高效交互？是否使用过WebSocket或SignalR处理实时数据？
15、在配置S7协议的57个数据点时，如何设计数据结构以提高可维护性？是否采用配置文件或数据库动态加载？
16、在非标自动化项目中，你使用C#开发过哪些核心功能？请举例说明**委托和事件**在工业软件中的实际应用场景。
17、 在WPF中，如何通过**依赖属性**实现动态UI更新？请结合AGV调度系统的退出加密功能说明实现逻辑。
18、在多线程环境下，如何确保Modbus/S7协议通信的线程安全？是否使用过`ConcurrentQueue`或`lock`机制？
19、 你开发的Modbus读取小工具是如何保证数据实时性和可靠性的？是否支持异常重试或超时机制？
20、在S7协议中，如何处理PLC数据点的批量读写？是否遇到过数据包解析错误，如何解决的？
21、在部署AGV调度系统到Linux平台时，遇到过哪些环境兼容性问题？如何通过代码或配置解决？
22、现场调试中，若客户反馈WMS系统任务下发延迟，你会如何逐步排查问题？（从网络、数据库、代码逻辑角度分析）
23、 在江西铜业项目中，你提到“解决了多个数据同步和接口兼容性问题”，请详细描述一个具体问题及其解决方案。
24、在联调WMS与RDS系统时，如何确保任务下发与执行的原子性？是否使用事务或消息队列（如RabbitMQ）？
25、虽然简历中未提及机器视觉经验，若项目中需要集成视觉检测功能，你会如何快速学习并实现基础功能（如OpenCV调用）？
26、 若需通过C#调用相机SDK实现简单视觉定位（如二维码识别），你会如何设计技术方案？
27、了解机械臂控制协议（如Modbus TCP或EtherCAT）吗？如何通过C#实现机械臂的路径规划指令下发？
```

![[attachments/张海东.pdf]]
## 详细准备
######  1、什么是委托？委托分几种？有什么区别？平时用过哪几种？
>委托（delegate）：在 C# 中，委托（Delegate） 是一种类型安全的函数指针，它允许将方法作为参数传递给其他方法
>委托分三种:Action委托、Func委托和自定义委托同时还分单播委托和多播委托
>		其中Action委托是无返回值的，Function委托是有返回值的
>自定义委托：
>		

#### 1. 委托

- **委托**：类型安全的函数指针，用于封装方法。
    
- **种类**：`Action`（无返回值）、`Func`（有返回值）、自定义委托（`delegate`关键字）。
    
- **区别**：`Action`/`Func`为预定义泛型委托，自定义委托需显式声明。多播委托可绑定多个方法。
    
- **应用**：事件处理、回调机制，如异步操作完成后通知UI。
#### **1. 什么是委托？委托分几种？有什么区别？平时用过哪几种？**

- **委托（Delegate）**：可以理解为“方法的容器”。比如你有一个方法 `void SayHello() { Console.Write("Hello") }`，委托允许你将这个方法“装”进一个变量里，之后通过这个变量调用方法。
    
- **常见类型**：
    
    - **自定义委托**：用 `delegate` 关键字定义（如 `delegate void MyDelegate()`）。
        
    - **Action**：系统预定义的委托，可以装“无返回值的方法”（如 `Action action = SayHello`）。
        
    - **Func**：系统预定义的委托，可以装“有返回值的方法”（如 `Func<int> getNumber = () => 10`）。
        
- **区别**：`Action` 和 `Func` 是泛型委托，不用自己定义，直接就能用。比如 `Func<int, string>` 表示一个输入int、返回string的方法。
    
- **实际应用**：按钮点击事件（底层就是委托）、异步回调。比如你写了一个下载文件的方法，下载完成后用委托通知UI更新进度。
#### 2. 事件

- **事件**：基于委托的发布-订阅模式，限制外部只能订阅/取消订阅，触发仅在声明类内部。
#### 3. 泛型

- **泛型**：允许代码复用不同数据类型，如`List<T>`，提供编译时类型检查。
    

#### 4. 多线程

- **多线程**：程序并行执行多个任务，提升性能。需注意线程安全（竞态条件、死锁）。
    

#### 5. 委托与事件应用及线程安全

- **应用场景**：WPF中后台任务完成时通过事件更新UI。
    
- **线程安全**：使用`Dispatcher.Invoke`同步到UI线程，或使用`lock`保护共享数据。
    

#### 6. WPF依赖属性

- **区别**：依赖属性支持数据绑定、动画、样式，值由属性系统管理。
    
- **代码示例**：
    
    csharp
    
    复制
    
    public class MyControl : DependencyObject {
        public static readonly DependencyProperty MyProperty = 
            DependencyProperty.Register("My", typeof(int), typeof(MyControl), new PropertyMetadata(0));
        public int My { get => (int)GetValue(MyProperty); set => SetValue(MyProperty, value); }
    }
    
- **数据绑定**：通过`Binding`表达式自动更新UI。
    

#### 7. ASP.NET Core依赖注入生命周期

- **生命周期**：
    
    - Transient：每次请求新实例。
        
    - Scoped：同一作用域内单例（如HTTP请求）。
        
    - Singleton：全局单例。
        
- **问题**：Scoped服务注入Singleton会导致Scoped实例变为隐式Singleton，引发数据污染。
    

#### 8. EFCore变更跟踪与优化

- **机制**：默认跟踪实体修改，调用`SaveChanges`时生成SQL。
    
- **优化**：`AsNoTracking()`禁用跟踪，减少内存占用，适用于只读查询。
#### **8. EFCore的变更跟踪机制**

- **工作机制**：EF Core默认会跟踪从数据库查询的实体。当调用 `SaveChanges()` 时，比较实体的当前值和原始值，生成更新SQL。
    
- **性能优化**：如果只是读取数据不需要更新，用 `AsNoTracking()` 禁用跟踪：
    
    csharp
    
    复制
    
    var users = context.Users.AsNoTracking().ToList(); // 不跟踪变更，查询更快
    

#### 9. Dapper优势场景

- **场景**：高性能读操作、复杂SQL或存储过程。例如报表生成时直接执行SQL映射到对象。
    

#### 10. Task与Thread区别

- **Task**：基于线程池的抽象，支持异步/等待。
    
- **async/await**：非阻塞UI，如：
    
    csharp
    
    复制
    
    async void LoadData() {
        var data = await Task.Run(() => GetData());
        UpdateUI(data);
    }
    

#### 11. ConcurrentQueue数据一致性

- **实现**：线程安全的队列，无需额外锁。
    
#### 12. Modbus TCP vs S7协议

- **差异**：Modbus TCP简单开放，S7协议复杂专有（西门子PLC）。
    
- **实时性**：缩短轮询间隔，使用异步IO；可靠性通过CRC校验、重试机制。
    

#### 13. 数据库优化

- **索引设计**：为高频查询字段（如订单号）添加索引。
    
- **查询优化**：避免`SELECT *`，分页查询，使用`EXPLAIN`分析执行计划。
    

#### 14. Vue3前后端交互

- **高效交互**：Axios封装REST API，WebSocket实时推送任务状态。
    
- **实时数据**：使用SignalR实现双向通信，如AGV位置实时更新。
    

#### 15. S7数据点设计

- **数据结构**：配置文件（JSON/YAML）定义数据点地址、类型，运行时动态加载。
    
    json
    
    复制
    
    { "Address": "DB1.DBD0", "Type": "Float", "Name": "Temperature" }
    

#### 16. 工业软件中的委托与事件

- **应用**：PLC数据到达时触发事件，委托处理数据解析。如传感器触发报警事件。
    

#### 17. WPF依赖属性动态UI

- **实现**：定义依赖属性绑定UI控件，属性变更触发更新。例如加密状态改变时按钮启用状态自动切换。
    

#### 18. 协议通信线程安全

- **方法**：使用`ConcurrentQueue`缓冲读写指令，或`lock`确保单线程访问PLC连接。
    

#### 19. Modbus工具可靠性

- **机制**：超时（如1秒）、重试（3次），异常日志记录，数据校验（CRC）。
    

#### 20. S7批量读写与解析

- **批量处理**：使用`ReadMultipleVars`方法读取多个数据点。
    
- **错误解决**：日志记录原始数据包，检查字节序和数据类型匹配。
    

#### 21. Linux部署问题

- **问题**：路径大小写、依赖库缺失。
    
- **解决**：使用Docker容器化，确保环境一致性。
    

#### 22. WMS延迟排查

- **步骤**：
    
    1. 网络：Ping/带宽测试。
        
    2. 数据库：慢查询日志、索引优化。
        
    3. 代码：检查锁竞争、异步调用阻塞。
        

#### 23. 数据同步问题案例

- **问题**：ERP与WMS数据格式不一致。
    
- **解决**：开发中间件转换数据格式，使用RabbitMQ确保可靠传输。
    

#### 24. 任务原子性保障

- **方法**：数据库事务保证本地操作原子性，消息队列（如RabbitMQ）确保跨系统一致性。
    

#### 25. 集成机器视觉

- **学习路径**：OpenCV教程，使用EmguCV（C#封装），实现基础图像处理（边缘检测、模板匹配）。
    

#### 26. 视觉定位设计

- **方案**：
    
    1. 相机SDK初始化并捕获图像。
        
    2. 使用EmguCV解码二维码。
        
    3. 坐标数据通过TCP发送给控制系统。
        

#### 27. 机械臂控制实现

- **协议**：基于Modbus TCP发送指令（目标坐标、速度）。
    
- **路径规划**：C#算法生成路径点，封装为协议数据包发送。