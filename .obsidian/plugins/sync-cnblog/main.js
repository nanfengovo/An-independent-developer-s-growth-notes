/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SyncCnblogPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/Setting.ts
var import_obsidian2 = require("obsidian");

// src/utils/CacheUtil.ts
var CacheUtil = class {
  static getSettings() {
    return this.settings;
  }
  static setSettings(settings) {
    this.settings = settings;
  }
  static async saveSettings() {
    return SyncCnblogPlugin.getPluginThis().saveData(this.settings);
  }
};

// src/utils/WeblogClient.ts
var import_obsidian = require("obsidian");

// src/model/structs/BlogInfo.ts
var BlogInfo = class {
};

// src/model/structs/UrlData.ts
var UrlData = class {
};

// src/model/XmlMember.ts
var XmlMember = class {
  constructor(name, type, value) {
    this.name = name;
    this.type = type;
    this.value = value;
  }
  toString() {
    return `<member><name>${this.name}</name><value><${this.type}>${this.value}</${this.type}></value></member>`;
  }
};

// src/model/structs/Post.ts
var Post = class {
  toReqXml() {
    let rtnXml = "";
    let members = [];
    if (this.description) {
      members.push(new XmlMember("description", "string", "<![CDATA[" + this.description + "]]>"));
    }
    if (this.title) {
      members.push(new XmlMember("title", "string", this.title));
    }
    if (this.mt_keywords) {
      members.push(new XmlMember("mt_keywords", "string", this.mt_keywords));
    }
    if (this.dateCreated) {
      members.push(new XmlMember("dateCreated", "dateTime.iso8601", this.dateCreated));
    }
    rtnXml += `${members.join("")}`;
    rtnXml += "<member><name>categories</name><value><array><data><value><string>[Markdown]</string></value></data></array></value></member>";
    return rtnXml;
  }
};

// src/utils/XmlUtil.ts
function generateReqXml(apiType, params) {
  let xml = '<?xml version="1.0"?>\n<methodCall>\n    <methodName>' + apiType + "</methodName>\n    <params>\n";
  for (let i = 0; i < params.length; i++) {
    xml += params[i].toString();
  }
  xml += "    </params>\n</methodCall>";
  return xml;
}
function parseRespXml(apiType, respXml) {
  const xmlDoc = new DOMParser().parseFromString(respXml, "text/xml");
  let rtnData;
  if (apiType === "blogger.getUsersBlogs" /* GETUSERSBLOGS */) {
    rtnData = [];
    let structs = xmlDoc.querySelectorAll("struct");
    if (structs) {
      structs.forEach((struct) => {
        let members = struct.querySelectorAll("member");
        let blogInfo = new BlogInfo();
        members.forEach((member) => {
          let name = member.querySelector("name").textContent.trim();
          let value = member.querySelector("value").textContent.trim();
          blogInfo[name] = value;
        });
        rtnData.push(blogInfo);
      });
    }
  } else if (apiType === "metaWeblog.newMediaObject" /* NEWMEDIAOBJECT */) {
    rtnData = new UrlData();
    let url = xmlDoc.querySelector("string").textContent;
    rtnData.url = url;
  } else if (apiType === "metaWeblog.getRecentPosts" /* GETRECENTPOSTS */) {
    rtnData = [];
    let structs = xmlDoc.querySelectorAll("struct");
    if (structs) {
      structs.forEach((struct) => {
        let members = struct.querySelectorAll("member");
        let post = new Post();
        members.forEach((member) => {
          let name = member.querySelector("name").textContent.trim();
          let value = member.querySelector("value").textContent.trim();
          post[name] = value;
        });
        rtnData.push(post);
      });
    }
  } else if (apiType === "metaWeblog.newPost" /* NEWPOST */) {
    rtnData = xmlDoc.querySelector("string").textContent.trim();
  }
  return rtnData;
}

// src/model/XmlStruct.ts
var XmlStruct = class {
  constructor(members) {
    this.members = members;
  }
  toString() {
    return `${this.members.join("")}`;
  }
};

// src/model/XmlParam.ts
var XmlParam = class {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  toString() {
    return `<param><value><${this.type}>${this.value}</${this.type}></value></param>`;
  }
  getType() {
    return this.type;
  }
  getValue() {
    if (this.type === "struct") {
      let members = [];
      const xmlDoc = new DOMParser().parseFromString(this.value, "text/xml");
      let memberEl = xmlDoc.getElementsByTagName("member");
      if (memberEl) {
        for (let i = 0; i < memberEl.length; i++) {
          const name = memberEl[i].getElementsByTagName("name")[0].textContent;
          const type = memberEl[i].getElementsByTagName("value")[0].children[0].tagName;
          const value = memberEl[i].getElementsByTagName("value")[0].children[0].textContent;
          members.push(new XmlMember(name ? name : "", type ? type : "", (value ? value : "").trim()));
        }
        return new XmlStruct(members);
      }
    } else {
      return this.value;
    }
  }
};

// src/model/structs/FileData.ts
var FileData = class {
  toReqXml() {
    let members = [];
    if (this.bits) {
      members.push(new XmlMember("bits", "base64", this.bits));
    }
    if (this.name) {
      members.push(new XmlMember("name", "string", this.name));
    }
    if (this.type) {
      members.push(new XmlMember("type", "string", this.type));
    }
    return `${members.join("")}`;
  }
};

// src/utils/WeblogClient.ts
var WeblogClient = class {
  /**
   * 获取用户的博客信息
   * 主要用于检测用户输入的参数是否正确
   */
  static async getUsersBlogs() {
    const params = [
      new XmlParam("string", ""),
      new XmlParam("string", CacheUtil.getSettings().username),
      new XmlParam("string", CacheUtil.getSettings().password)
    ];
    let respXml = await this.sendRequest("blogger.getUsersBlogs" /* GETUSERSBLOGS */, params);
    return parseRespXml("blogger.getUsersBlogs" /* GETUSERSBLOGS */, respXml);
  }
  static getCategories() {
    const params = [
      new XmlParam("string", ""),
      new XmlParam("string", CacheUtil.getSettings().username),
      new XmlParam("string", CacheUtil.getSettings().password)
    ];
    this.sendRequest("metaWeblog.getCategories" /* GETCATEGORIES */, params).then((res) => {
      const xml = new DOMParser().parseFromString(res, "text/xml");
    });
  }
  static newMediaObject(name, type, base64Img) {
    let fileData = new FileData();
    fileData.bits = base64Img;
    fileData.name = name;
    fileData.type = type;
    const params = [
      new XmlParam("string", ""),
      new XmlParam("string", CacheUtil.getSettings().username),
      new XmlParam("string", CacheUtil.getSettings().password),
      new XmlParam("struct", fileData.toReqXml())
    ];
    return this.sendRequest("metaWeblog.newMediaObject" /* NEWMEDIAOBJECT */, params);
  }
  static getRecentPosts() {
    const params = [
      new XmlParam("string", ""),
      new XmlParam("string", CacheUtil.getSettings().username),
      new XmlParam("string", CacheUtil.getSettings().password),
      new XmlParam("i4", "1000")
    ];
    return this.sendRequest("metaWeblog.getRecentPosts" /* GETRECENTPOSTS */, params);
  }
  static async getPost(postId) {
    const params = [
      new XmlParam("string", ""),
      new XmlParam("string", CacheUtil.getSettings().username),
      new XmlParam("string", CacheUtil.getSettings().password),
      new XmlParam("string", postId)
    ];
    let respXml = await this.sendRequest("metaWeblog.getPost" /* GETPOST */, params);
    return parseRespXml("metaWeblog.getPost" /* GETPOST */, respXml);
  }
  static async newPost(post) {
    const params = [
      new XmlParam("string", ""),
      new XmlParam("string", CacheUtil.getSettings().username),
      new XmlParam("string", CacheUtil.getSettings().password),
      new XmlParam("struct", post.toReqXml()),
      new XmlParam("boolean", "1")
    ];
    return this.sendRequest("metaWeblog.newPost" /* NEWPOST */, params);
  }
  static async editPost(post) {
    const params = [
      new XmlParam("string", post.postid),
      new XmlParam("string", CacheUtil.getSettings().username),
      new XmlParam("string", CacheUtil.getSettings().password),
      new XmlParam("struct", post.toReqXml()),
      new XmlParam("boolean", "1")
    ];
    return this.sendRequest("metaWeblog.editPost" /* EDITPOST */, params);
  }
  static sendRequest(apiType, params) {
    const requestUrlParam = {
      contentType: "application/xml",
      method: "POST",
      url: CacheUtil.getSettings().blogUrl,
      body: generateReqXml(apiType, params)
    };
    return (0, import_obsidian.request)(requestUrlParam);
  }
};

// src/Setting.ts
var DEFAULT_SETTINGS = {
  blogUrl: "",
  // blog_id 链接成功可以回写，暂时没用到
  blog_id: "",
  username: "",
  password: "",
  // 需要同步的文章目录, 默认是所有文章, 路径/子路径
  locationPosts: "/",
  throttlingMode: true
};
var SyncCnblogSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl: contentEl } = this;
    contentEl.empty();
    new import_obsidian2.Setting(contentEl).setName("blogUrl").setDesc("MetaWeblog\u8BBF\u95EE\u5730\u5740").addText((text) => text.setPlaceholder("MetaWeblog\u8BBF\u95EE\u5730\u5740").setValue(CacheUtil.getSettings().blogUrl).onChange(async (value) => {
      CacheUtil.getSettings().blogUrl = value;
      await CacheUtil.saveSettings();
    }));
    new import_obsidian2.Setting(contentEl).setName("username").setDesc("MetaWeblog\u767B\u5F55\u540D").addText((text) => text.setPlaceholder("MetaWeblog\u767B\u5F55\u540D").setValue(CacheUtil.getSettings().username).onChange(async (value) => {
      CacheUtil.getSettings().username = value;
      await CacheUtil.saveSettings();
    }));
    new import_obsidian2.Setting(contentEl).setName("password").setDesc("MetaWeblog\u8BBF\u95EE\u4EE4\u724C").addText(
      (text) => {
        text.setPlaceholder("MetaWeblog\u8BBF\u95EE\u4EE4\u724C").setValue(CacheUtil.getSettings().password).onChange(async (value) => {
          CacheUtil.getSettings().password = value;
          await CacheUtil.saveSettings();
        });
        text.inputEl.setAttribute("type", "password");
      }
    );
    let all_dir = this.plugin.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian2.TFolder);
    new import_obsidian2.Setting(contentEl).setName("locationPosts").setDesc("\u9009\u62E9\u6587\u7AE0\u76EE\u5F55\uFF0C\u540C\u6B65\u6587\u7AE0\u65F6\u5C06\u53EA\u4E0A\u4F20\u8BE5\u76EE\u5F55\u4E0B\u7684\u6587\u7AE0").setTooltip("\u540C\u6B65\u6587\u7AE0\u76EE\u5F55, \u9ED8\u8BA4\u662F\u6240\u6709\u6587\u7AE0").addDropdown((dropdown) => {
      all_dir.forEach((dir) => {
        dropdown.addOption(dir.path, dir.path);
      });
      if (CacheUtil.getSettings().locationPosts === "" || CacheUtil.getSettings().locationPosts === void 0) {
        dropdown.setValue("/");
      } else {
        dropdown.setValue(CacheUtil.getSettings().locationPosts);
      }
      dropdown.onChange(async (value) => {
        CacheUtil.getSettings().locationPosts = value;
        await CacheUtil.saveSettings();
      });
    });
    new import_obsidian2.Setting(contentEl).setName("throttlingMode").setDesc("\u542F\u7528\u8282\u6D41\u6A21\u5F0F\u540E\uFF0C\u5DF2\u4E0A\u4F20\u7684\u540C\u540D\u56FE\u7247\u4E0D\u4F1A\u518D\u4E0A\u4F20\uFF0C\u8282\u7701\u63A5\u53E3\u8C03\u7528\u6B21\u6570").addToggle((toggle) => toggle.setTooltip("\u542F\u7528\u8282\u6D41\u6A21\u5F0F\u540E\uFF0C\u5DF2\u4E0A\u4F20\u7684\u540C\u540D\u56FE\u7247\u4E0D\u4F1A\u518D\u4E0A\u4F20\uFF0C\u8282\u7701\u63A5\u53E3\u8C03\u7528\u6B21\u6570").setValue(CacheUtil.getSettings().throttlingMode).onChange(async (value) => {
      CacheUtil.getSettings().throttlingMode = value;
      await CacheUtil.saveSettings();
    }));
    new import_obsidian2.Setting(contentEl).setName("testLink").setDesc("\u6D4B\u8BD5\u535A\u5BA2\u56EDMetaWeblog\u7684\u94FE\u63A5\u662F\u5426\u53EF\u7528").addButton(
      (button) => button.setButtonText("\u6D4B\u8BD5").onClick(async () => {
        if (!CacheUtil.getSettings().blogUrl || !CacheUtil.getSettings().username || !CacheUtil.getSettings().password) {
          new import_obsidian2.Notice("\u8BF7\u5148\u914D\u7F6E\u535A\u5BA2\u56EDMetaWeblog\u7684\u94FE\u63A5\u3001\u767B\u5F55\u540D\u3001\u5BC6\u7801");
        } else {
          try {
            let blogs = await WeblogClient.getUsersBlogs();
            if (blogs[0].blogName === void 0) {
              new import_obsidian2.Notice("\u94FE\u63A5\u5F02\u5E38, \u8BF7\u68C0\u67E5\u7F51\u7EDC\u53CA\u76F8\u5173\u53C2\u6570\u586B\u5199\u662F\u5426\u6B63\u786E!");
              return;
            }
            let sync_dir = this.app.vault.getAbstractFileByPath(CacheUtil.getSettings().locationPosts);
            if (sync_dir == null && CacheUtil.getSettings().locationPosts != "") {
              new import_obsidian2.Notice("\u6587\u7AE0\u540C\u6B65\u76EE\u5F55\u4E0D\u5B58\u5728, \u5C06\u6309\u7167\u9ED8\u8BA4\u8BBE\u7F6E\u8FDB\u884C\u540C\u6B65!");
              return;
            }
            new import_obsidian2.Notice("Hello, " + blogs[0].blogName + "!");
          } catch (e) {
            new import_obsidian2.Notice("\u94FE\u63A5\u5F02\u5E38, \u8BF7\u68C0\u67E5\u7F51\u7EDC\u53CA\u76F8\u5173\u53C2\u6570\u586B\u5199\u662F\u5426\u6B63\u786E!");
          }
        }
      })
    );
  }
};

// src/utils/MdFile.ts
var import_obsidian3 = require("obsidian");
async function getMdContent(file) {
  const { vault } = SyncCnblogPlugin.getPluginThis().app;
  return await vault.cachedRead(file);
}
function findAllEmbeds(file) {
  const { metadataCache } = SyncCnblogPlugin.getPluginThis().app;
  const cache = metadataCache.getFileCache(file);
  if (cache === null) {
    return [];
  }
  const { embeds } = cache;
  return embeds ? embeds : [];
}
function findKeywords(file) {
  const { metadataCache } = SyncCnblogPlugin.getPluginThis().app;
  const metadata = metadataCache.getFileCache(file);
  const tags = metadata ? (0, import_obsidian3.getAllTags)(metadata) : [];
  if (tags == null) {
    return "";
  }
  return tags.length > 0 ? tags.map((tag) => tag.substring(1)).join(",") : "";
}
function getImg(embed, file) {
  let currentPath = file.parent;
  let imgLink = embed.link;
  let metadataCache = SyncCnblogPlugin.getPluginThis().app.metadataCache;
  return metadataCache.getFirstLinkpathDest(imgLink, "/");
}
async function uploadImgs(embeds, uploadImgs2, file, plugin) {
  let rtnImgs = [];
  const imgBatchPromises = embeds.map(async (embed) => {
    let img = getImg(embed, file);
    if (img != null) {
      let map = /* @__PURE__ */ new Map();
      map.set("link", embed.link);
      map.set("displayText", embed.displayText);
      map.set("original", embed.original);
      map.set("start_line", embed.position.start.line);
      map.set("start_col", embed.position.start.col);
      map.set("start_offset", embed.position.start.offset);
      map.set("end_line", embed.position.end.line);
      map.set("end_col", embed.position.end.col);
      map.set("end_offset", embed.position.end.offset);
      if (embed.link.endsWith(".jpg") || embed.link.endsWith(".png") || embed.link.endsWith(".svg") || embed.link.endsWith(".gif") || embed.link.endsWith(".webp")) {
        let isUpload = false;
        uploadImgs2.forEach((img2) => {
          let netAltText = img2[0];
          let netImgUrl = img2[1];
          if (netAltText == embed.link) {
            map.set("url", netImgUrl);
            isUpload = true;
          }
        });
        if (!isUpload) {
          let imgContent = await plugin.app.vault.readBinary(img);
          let respMag = await WeblogClient.newMediaObject(img.name, img.extension, (0, import_obsidian3.arrayBufferToBase64)(imgContent));
          if (respMag.indexOf("\u5931\u8D25") > -1) {
            return;
          }
          let urlData = parseRespXml("metaWeblog.newMediaObject" /* NEWMEDIAOBJECT */, respMag);
          map.set("url", urlData.url);
        }
      } else {
        map.set("url", "\u4E0D\u652F\u6301\u5C55\u793A\u7684\u9644\u4EF6");
      }
      rtnImgs.push(map);
    }
  });
  await Promise.all(imgBatchPromises);
  return rtnImgs;
}
async function replaceImgLocalToNet(mdContent, embeds) {
  embeds.sort((a, b) => {
    return Number(b.get("start_offset")) - Number(a.get("start_offset"));
  });
  for (const embed of embeds) {
    let link = String(embed.get("link"));
    let displayText = embed.get("displayText");
    let original = embed.get("original");
    let url = embed.get("url");
    let start_line = Number(embed.get("start_line"));
    let start_col = Number(embed.get("start_col"));
    let start_offset = Number(embed.get("start_offset"));
    let end_line = Number(embed.get("end_line"));
    let end_col = Number(embed.get("end_col"));
    let end_offset = Number(embed.get("end_offset"));
    let selectedContent = mdContent.substring(Number(start_offset), Number(end_offset));
    if (url != void 0) {
      if (url != "\u4E0D\u652F\u6301\u5C55\u793A\u7684\u9644\u4EF6") {
        selectedContent = selectedContent.replace(/!\[.*?]/g, "![" + link + "]");
        selectedContent = selectedContent.replace(/\((.*?)\)/g, "(" + url + ")");
      } else {
        selectedContent = "";
      }
    }
    mdContent = mdContent.substring(0, start_offset) + selectedContent + mdContent.substring(end_offset);
  }
  return mdContent;
}
async function getThePost(file) {
  let newPost = await getThePostByName(file.basename);
  newPost.title = file.basename;
  let dateCreated = new Date(file.stat.ctime);
  let year = dateCreated.getFullYear();
  let month = dateCreated.getMonth() + 1;
  let date = dateCreated.getDate();
  let hours = dateCreated.getHours();
  let minutes = dateCreated.getMinutes();
  let seconds = dateCreated.getSeconds();
  newPost.dateCreated = "" + year + (month < 10 ? "0" + month : month) + (date < 10 ? "0" + date : date) + "T" + (hours < 10 ? "0" + hours : hours) + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
  return newPost;
}
async function getThePostByName(fileName) {
  let respXml = await WeblogClient.getRecentPosts();
  if (respXml) {
    let posts = parseRespXml("metaWeblog.getRecentPosts" /* GETRECENTPOSTS */, respXml);
    for (let i = 0; i < posts.length; i++) {
      let post = posts[i];
      if (post.title == fileName) {
        return post;
      }
    }
  }
  return new Post();
}
async function uploadPost(post) {
  let resp;
  let userId = CacheUtil.getSettings().blogUrl.substring(CacheUtil.getSettings().blogUrl.lastIndexOf("/"));
  if (post.postid === void 0) {
    resp = await WeblogClient.newPost(post);
    let respStr = parseRespXml("metaWeblog.newPost" /* NEWPOST */, resp);
    if (resp.indexOf("faultString") <= 0) {
      await navigator.clipboard.writeText((0, import_obsidian3.normalizePath)("https://www.cnblogs.com/" + userId + "/p/" + respStr));
      return post.title + "\u4E0A\u4F20\u6587\u7AE0\u6210\u529F, \u535A\u6587\u94FE\u63A5\u5DF2\u590D\u5236\u5230\u526A\u5207\u677F";
    } else {
      return "\u4E0A\u4F20\u6587\u7AE0\u5931\u8D25, \u9519\u8BEF\u539F\u56E0\u4E3A" + respStr;
    }
  } else {
    resp = await WeblogClient.editPost(post);
    if (resp.indexOf("faultString") <= 0) {
      await navigator.clipboard.writeText((0, import_obsidian3.normalizePath)("https://www.cnblogs.com/" + userId + "/p/" + post.postid));
      return post.title + "\u6587\u7AE0\u66F4\u65B0\u6210\u529F, \u535A\u6587\u94FE\u63A5\u5DF2\u590D\u5236\u5230\u526A\u5207\u677F";
    }
  }
  return "\u4E0A\u4F20\u6587\u7AE0\u5931\u8D25";
}
function getUploadedImgs(post) {
  let md = post.description;
  let rtnImgs = [];
  if (md && CacheUtil.getSettings().throttlingMode) {
    let imgs = md.match(/!\[(.*?)\]\((.*?)\)/g);
    if (imgs) {
      for (let i = 0; i < imgs.length; i++) {
        let img = imgs[i];
        let matchArray = img.match(/!\[(.*?)\]\((.*?)\)/);
        if (matchArray && matchArray.length > 0) {
          let netAltText = matchArray[1];
          let netImgUrl = matchArray[2];
          rtnImgs.push([netAltText, netImgUrl]);
        }
      }
    }
  }
  return rtnImgs;
}

// main.ts
var SyncCnblogPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.initPlug();
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        let locationPosts = CacheUtil.getSettings().locationPosts;
        if (!file.path.startsWith(locationPosts) && locationPosts != "/" && locationPosts != "" && locationPosts != void 0) {
          return;
        }
        if (file instanceof import_obsidian4.TFile) {
          if (file.extension === "md") {
            menu.addItem((item) => {
              item.setTitle("\u540C\u6B65\u5230\u535A\u5BA2\u56ED").setIcon("upload").onClick(async () => {
                await this.rightClickToUpload(file);
              });
            });
          }
        }
      })
    );
    this.registerEvent(this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian4.TFile) {
        if (file.extension === "md") {
          new import_obsidian4.Notice("" + file.name + "\u6587\u7AE0\u4E0D\u4F1A\u5728\u535A\u5BA2\u56ED\u5220\u9664!");
        }
      }
    }));
    this.registerEvent(this.app.vault.on("rename", async (newFile, oldPath) => {
      if (newFile instanceof import_obsidian4.TFile) {
        if (newFile.extension === "md") {
          let oldFileName = oldPath.split("/").pop().substring(0, oldPath.split("/").pop().lastIndexOf("."));
          let post = await getThePostByName(oldFileName);
          if (post.postid !== void 0) {
            post.title = newFile.basename;
            new import_obsidian4.Notice(await uploadPost(post));
          }
        }
      }
    }));
  }
  onunload() {
  }
  static getPluginThis() {
    return SyncCnblogPlugin.plugin_this;
  }
  /**
   * 初始化插件, 加载必要数据
   */
  async initPlug() {
    if (!SyncCnblogPlugin.plugin_this) {
      SyncCnblogPlugin.plugin_this = this;
    }
    this.addSettingTab(new SyncCnblogSettingTab(this.app, this));
    CacheUtil.setSettings(Object.assign({}, DEFAULT_SETTINGS, await this.loadData()));
  }
  async rightClickToUpload(file) {
    let content = await getMdContent(file);
    const embeds = findAllEmbeds(file);
    let post = await getThePost(file);
    let uploadedImgs = getUploadedImgs(post);
    let addUrlEmbeds = await uploadImgs(embeds, uploadedImgs, file, this);
    post.description = await replaceImgLocalToNet(content, addUrlEmbeds);
    post.title = file.basename;
    post.mt_keywords = findKeywords(file);
    new import_obsidian4.Notice(await uploadPost(post));
  }
};

/* nosourcemap */